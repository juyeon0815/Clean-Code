## Chapter 13. 동시성

- 여러 스레드를 동시에 돌리는 이유와 그에 대한 어려움
- 어려움을 대처하고 깨끗한 코드를 작성하는 방법 제안
- 동시성을 테스트하는 방법과 문제점



### 동시성이 필요한 이유?

- 동시성은 결합을 없애는 전략 = **무엇**과 **언제**를 분리하는 전략이다.

- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.



[예시]

- 매일 수 많은 웹 사이트에서 정보를 가져와 요약하는 정보 수집기

  - 만약 정보 수집기가 단일 스레드 프로그램이라면 한 번에 한 웹 사이트에 대한 정보만 가져올 수 있다.
  - 한 사이트를 끝내야 다음 사이트의 정보를 가져올 수 있으므로 너무 많은 시간이 소요된다.

  -> 한 번에 한 사이트를 방문하는 대신 다중 스레드를 이용하면 수집기의 성능을 높일 수 있다.

- 한 번에 한 사용자를 처리하는 시스템

  - 사용자가 소수라면 시스템 반응속도가 빠를테지만, 사용자가 늘어나면 늘어날수록 시스템의 응답속도는 늦어진다.

  -> 많은 사용자를 동시에 처리하면 시스템 응답 시간을 높일 수 있다.

- 정보를 대량으로 분석하는 시스템

  - 모든 정보를 처리한 후에야 최종적인 답을 도출할 수 있는 경우, 여러 컴퓨터에서 정보를 나눠 돌려 대량의 정보를 병렬 처리할 수 있다면 시스템의 성능을 높일 수 있다.



##### 미신과 오해

- 동시성은 항상 성능을 높여준다.
  - 대기 시간이 길어 여러 스레드가 프로세서를 공유할 수 있는 경우
  - 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우
- 동시성을 구현해도 설계는 변하지 않는다.
  - **무엇**과 **언제**를 분리하면 시스템 구조가 크게 달라진다.

- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
  - 컨테이너가 어떻게 동작하는지, 어떻게 동시 수저으 데드락 등과 같은 문제를 피할 수 있는지 알아야한다.



##### 동시성과 관련된 생각

- 동시성은 부하를 유발한다.
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하려면 근본적인 설계 전략을 재고해야 한다.



### 난관

```java
public class X {
    private int lastIdUsed;
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

- lastIdUsed를 42로 가정. 두 스레드가 해당 인스턴스를 공유하고 getNextId();를 호출한다면?
  - 스레드 1 : 43, 스레드 2 : 44 / lastIdUsed : 44
  - 스레드 1 : 44, 스레드 2 : 43 / lastIdUsed : 44
  - **스레드 1 : 43, 스레드 2 : 43 / lastIdUsed : 43**

​			-> 두 스레드가 같은 변수를 동시에 참조할 경우 위와 같은 결과 발생



### 동시성 방어 원칙

##### 단일 책임 원칙 (Single Responsibility Principle)

- 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙
- **동시성 관련 코드는 다른 코드와 분리해야 한다.**



##### 따름 정리 : 자료 범위를 제한하라

- 두 스레드가 서로 간섭할 경우, 예상치 못한 결과 발생
  - 공유 객체를 사용하는 코드 내 **임계영역을 synchronized 키워드로 보호**

- 공유 자료를 수정하는 위치가 많을수록 다음 가능성도 커진다.
  - 보호할 임계영역을 빼먹어 공유자료를 수정한느 모든 코든을 망가뜨린다.
  - 임계영역을 보호했는지 확인하느라 노력과 수고를 반복한다.
  - 찾아내기 어려운 버그가 더욱 찾기 어려워진다.
- **자료를 캡슐화하고 공유 자료를 최대한 줄여야 한다.**



##### 따름 정리 : 자료 사본을 사용하라

- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
- 객체를 복사해 읽기 전용으로 사용하는 방법
- 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법
- 공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성도 낮아진다.



##### 따름 정리 : 스레드는 가능한 독립적으로 구현해라

- 다른 스레드와 자료를 공유하지 않는 스레드 구현한다.
  - 스레드는 다른 스레드와 동기화할 필요가 없으므로 자신만 있는 듯이 돌아갈 수 있다.

- **독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할한다.**



##### 라이브러리를 이해하라

- 스레드 코드 구현 시 고려할 사항
  - 스레드 환경에 안전한 컬렉션 사용
  - 서로 무관한 작업을 수행할 때는 executor 프레임워크 사용
  - 가능한 스레드가 차단되지 않는 방법을 이용
  - 일부 클래스 라이브러리는 스레드에 안전하지 못하다는 사실



[스레드 환경에 안전한 컬렉션]

- java.util.concurrent 패키지가 제공하는 클래스는 다중 스레드 환경에서 사용해도 안전하며 성능도 좋다.
  - ConcurrentHashMap은 HashMap보다 빠르며, 동시 읽기/쓰기를 지원, 복합 연산을 다중 스레드 상에서 안전하게 만든 메서드로 제공
- 이외에도 ReentrantLock, Semaphore, CountDownLatch 클래스가 있다.



### 실행 모델을 이해하라

##### 생산자-소비자

```java
//소비자
while(true) {
    while(count == 0)
        ; /* do notiong */
    
    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    count--;
}

//생산자
while(true) {
    while(count == BUFFER_SIZE)
        ; /* do notiong */
    
    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE;
    count++;
}
```

- 소비자와 생산자는 count라는 공유변수를 이용해 생성과 소비 진행
- 하지만, 두 프로세스를 동시에 실행시켜보면 생산자 스레드는 대기열에 빈 공간이 존재하지 않음에도 불구하고 계속 만들고, 소비자 스레드는 대기열에 빈 공간임에도 불구하고 계속해서 소비하는 경우가 발생한다.
  - 이러한 문제가 발생하는 이유? = **동기화가 되지 않았기 때문에**



- 내가 아는 생산자-소비자 문제는 위의 경우인데 책에서는 생산자/소비자 스레드가 진행 가능함에도 불구하고 기다린다는 내용인데 뭐가 맞는건지.. 



##### 읽기-쓰기

- 쓰기 스레드가 버퍼를 갱신하는 동안 읽기 스레드는 버퍼를 읽지 않아야하고, 읽기 쓰레드가 버퍼를 읽는 동안 쓰기 스레드는 버퍼를 갱신하지 않아야한다.
- 처리율(쓰기)를 강조한다면 읽기 쪽에서는 계속 기다려야하는 기아 현상이 생길 가능성이 있다.
- 해당 문제를 해결하기 위해서 **읽기 쓰레드와 쓰기 스레드를 적절히 만족시켜 처리율을 높이고 기아도 방지하는 방법 필요**



[식사하는 철학자들]

- 교착상태의 대표적인 예제로 DeadLock 발생의 **4가지 필요조건을 모두 만족**
- 만약 모든 철학자가 동시에 배가 고파서 왼쪽 젓가락을 집어든다면?
  - 모두가 영원히 오른쪽 젓가락을 들지 못한다.
  - 즉, **교착상태에 빠져 기아현상 발생** 



###### DeadLock 발생의 4가지 필요조건

1. 상호배타 (Mutual Exclusion)
   - 젓가락은 한번에 한 철학자만 사용할 수 있다.
2. 보유 및 대기 (Hold and Wait)
   - 집어든 젓가락은 계속 들은 채로 반대쪽 젓가락을 기다린다.
3. 비선점 (No Preemption)
   - 이미 누가 집어든 젓가락은 강제로 뺏을 수 없다.
4. 환형대기 (Circular Wait)
   - 모든 철학자들이 자신의 오른쪽에 앉은 철학자가 젓가락을 놓기를 기다린다.

-> 식사하는 철학자 예시는 위 네가지 조건 모두 만족



###### 그럼 어떻게 교착상태를 해결해야할까?

- 4가지 조건 중 하나만 성립하지 않아도 데드락이 발생하지 않기 때문에 전부 성립하는 일이 없게끔하면 된다.



### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

- **공유 객체 하나는 메서드 하나만 사용하는 것을 권장한다.**
- 만약 공유 객체 하나에 여러 메서드가 필요한 상황이라면?
  - 클라이언트에서 첫 번째 메서드 호출하기 전에 서버를 잠궈 마지막 메서드를 호출할 때까지 잠금을 유지한다.
  - 서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현한다.
  - 잠금을 수행하는 중간 단계를 생성한다.



### 동기화하는 부분을 작게 만들어라

- 락으로 감싼 코드 영역은 한 번에 한 스레드만 실행이 가능하여 스레드를 지연시키고 부하를 가중시키기 때문에 synchronized를 남발하는 코드는 바람직하지 않다.
- **코드를 짤 때 임계영역 수를 최대한 줄여야한다.**



### 올바른 종료 코드는 구현하기 어렵다

- 부모 스레드가 자식 스레드를 여러 개 만든 후, 모든 스레드가 끝나기를 기다렸다가 자원을 해제하고 종료하는 시스템이 있다고 가정
  - 만약 자식 스레드 중 하나가 데드락에 걸렸다면 부모 스레드는 영원히 기다리고, 시스템은 종료되지 않는다.
- **깔끔하게 종료되는 다중 스레드 코드를 짜야한다면 시간을 투자해 구현해야 한다.**



### 스레드 코드 테스트하기

- 테스트가 정확성을 보장하지 않기 때문에 코드가 올바르다고 증명하기는 어렵다.
- 문제를 노출하는 테스트 케이스를 작성하고, 프로그램 및 시스템 설정과 부하를 바꿔가며 테스트를 돌려라
- 테스트가 실패했는데 다시 돌렸더니 통과했다라는 이유로 그냥 넘어가선 안된다.



##### 고려할 사항

- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라.
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자.
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에서 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라.
- 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라.
- 프로세서 수보다 많은 스레드를 돌려봐라.
- 다른 플랫폼에서 돌려봐라.
- 코드에 보조 코드를 넣어 강제로 실패를 일으키제 해봐라.



[말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라]

- 다중 스레드 코드는 때때로 **말이 안되는 오류**를 일으킨다.
- 그래서 많은 개발자는 우주선, 하드웨어 문제, 단순한 **일회성 문제**로 치부하고 무시한다.
- 일회성 문제라 치부하고 무시한다면 잘못된 코드 위에 코드가 계속 쌓이므로 시스템 실패를 일회성이라 치부하면 안된다.



[다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자]

- 스레드 환경 밖에도 코드가 제대로 돌아가는지 반드시 확인한다.
- **스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라.**



[다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라]

- **다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있도록 코드를 구현한다.**



[다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라]

- 처음부터 다양한 설정으로 프로그램 성능 측정 방법을 강구하여 스레드 개수를 조율하기 쉽게 코드를 구현한다.
- 그 외에도 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법, 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민해본다.



[프로세서 수보다 많은 스레드를 돌려봐라]

- 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.



[다른 플랫폼에서 돌려봐라]

- 다중 스레드 코드는 플랫폼에 따라 다르게 돌아가므로 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 해봐야 한다.



[코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해봐라]

- 스레드 코드는 오류를 찾기 쉬울 뿐 아니라, 간단한 테스트로는 버그가 잘 드러나지 않는다.
- 보조 코드를 추가해 코드가 실행되는 순서를 바꿔 버그를 확인한다.

- 코드에 보조 코드를 추가하는 방법

  - 직접 구현하기

  ```java
  public synchronized String nextUrlOrNull() {
      if(hasNext()){
          String url = urlGenerator.next();
          Thread.yield(); //테스트를 위해 추가
          updateHasNext();
          return url;
      }
      return null;
  }
  ```

  - 위의 코드를 추가했을 때, 실패했다면 yield()를 추가해서가 아니라, 원래 잘못된 코드였기 때문이다.
  - 직접 구현하는 방법에는 다음과 같은 문제가 있다.
    - 보조 코드를 삽입할 적정 위치를 직접 찾아야한다.
    - 어떤 함수를 어디서 호출해야 적당한지
    - 배포 환경에서 보조 코드를 지우지 않았을 경우 프로그램 성능 저하
    - 보조 코드를 작성한다고 오류가 드러갈지 안들어날지 모른다.

  

  - 자동화

  ```java
  public class ThreadJigglePoint {
      public static void jiggle(){
          
      }
  }
  
  public synchronized String nextUrlOrNull() {
      if(hasNext()) {
          ThreadJigglePoint.jiggle();
          String url = urlGenerator.next();
          ThreadJigglePoint.jiggle();
          updateHashNext();
          ThreadJigglePoint.jiggle();
          return url;
      }
      return null;
  }
  ```

  - ThreadJigglePoint.jiggle() 호출은 무작위로 sleep/yield 호출 및 동작을 하지 않는다.
  - 코드를 흔드는 이유는 스레드를 매번 다른 순서로 실행하기 위해서다.
  - **좋은 테스트 케이스와 흔들기 기법은 오류가 드러날 확률을 높여준다.**



### 결론

- 다중 스레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야한다.
- 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다.
- 사용하는 라이브러리와 기본 알고리즘을 이해한다.
- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.
- 스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 한다.
- 시간을 들여 보조 코드를 추가하면 오류가 드러날 가능성이 크게 높아진다.